open Adt

type 'l stack = Failed | S of simple typ list

let typecheck param_t storage_t =
  let exception Type_error in
  let equal_typ = equal_typ (fun _ _ -> true) in
  let rec t s i =
    match s with
    Failed -> Failed
    | S s -> match i, s with
    | I_noop, _ -> s
    | I_abs, (T_int,()) :: s' -> S ((T_nat, ()) :: s')
  |I_failwith, _ -> Failed
   |I_exec, t_1 :: (T_lambda (t_1', t_2), ()) :: s' ->
      if equal_typ t_1 t_1' then
        S (t_2 :: s')
      else raise Type_error
    |I_apply, t_1 :: (T_lambda ((T_pair (t_1', t_2'),()), t_3),()) :: s' ->
      if equal_typ t_1 t_1' && equal_typ t_2 t_2' then
        S (T_lambda (t_2, t_3))
      else
        raise Type_error
     |I_drop, _ :: s' -> s'
      |I_dup, t :: s' -> t :: t:: s'

       |I_swap, t_1 :: t_2 :: s' -> t_2 :: t_1 :: s'
        |I_unit, s -> T_unit,() :: s
         |I_eq, (T_int,()) :: s' -> T_bool,() :: s'
          |I_neq, (T_int,()) :: s' -> T_bool,() :: s'
           |I_lt, (T_int,()) :: s' -> T_bool,() :: s'
            |I_gt, (T_int,()) :: s' -> T_bool,() :: s'
             |I_le, (T_int,()) :: s' -> T_bool,() :: s'
              |I_ge, (T_int,()) :: s' -> T_bool,() :: s'
               |I_or, (T_bool,()) :: (T_bool,()) :: s' -> T_bool,() :: s'
               |I_or, (T_nat,()) :: (T_nat,()) :: s' -> T_nat,() :: s'
                |I_and, (T_bool,()) :: (T_bool,()) :: s' -> T_bool,() :: s'
               |I_and, (T_nat,()) :: (T_nat,()) :: s' -> T_nat,() :: s'
               |I_and, (T_int,()) :: (T_nat,()) :: s' -> T_nat,() :: s'
                 |I_xor, (T_bool,()) :: (T_bool,()) :: s' -> T_bool,() :: s'
               |I_xor, (T_nat,()) :: (T_nat,()) :: s' -> T_nat,() :: s'
               |I_not, (T_bool,()) :: s' -> T_bool,() :: s'   
               |I_not, (T_nat,()) :: s' -> T_int,() :: s'
                  |I_not, (T_int,()) :: s' -> T_int,() :: s'
                   |I_neg, (T_nat,()) :: s' -> T_int,() :: s'
                   |I_neg, (T_int,()) :: s' -> T_int,() :: s'
                   |I_isnat, (T_int,()) :: s' -> (T_option (T_nat,()), ()) :: s'
                     |I_int, (T_nat,()) :: s' -> (T_int,()) :: s'
                      |I_add, (T_int,()) :: (T_int,()) :: s' -> (T_int,()) :: s'
                      |I_add, (T_int,()) :: (T_nat,()) :: s' -> (T_int,()) :: s'
                      |I_add, (T_nat,()) :: (T_int,()) :: s' -> (T_int,()) :: s'
                      |I_add, (T_nat,()) :: (T_nat,()) :: s' -> (T_nat,()) :: s'
                      |I_add, (T_timestamp,()) :: (T_int,()) :: s' -> (T_timestamp,()) :: s'
                      |I_add, (T_int,()) :: (T_timestamp,()) :: s' -> (T_timestamp,()) :: s'
                      |I_add, (T_mutez,()) :: (T_mutez,()) :: s' -> (T_mutez,()) :: s'
                       |I_sub , ((T_int | T_nat),()) :: ((T_int | T_nat),()) :: s' -> (T_int,()) :: s'
                       |I_sub , (T_timestamp,()) :: (T_int,()) :: s' -> (T_timestamp,()) :: s'
                       |I_sub , (T_timestamp,()) :: (T_timestamp,()) :: s' -> (T_int,()) :: s'
                       |I_sub , (T_mutez,()) :: (T_mutez,()) :: s' -> (T_mutez,()) :: s'
                        |I_mul, ((T_int | T_nat),()) :: (T_int,()) :: s' -> (T_int,()) :: s'
                        |I_mul, (T_int,()) :: ((T_int | T_nat),()) :: s' -> (T_int,()) :: s'
                        | I_mul, (T)
                         |I_ediv, ((T_int | T_nat),()) :: (T_int,()) :: s' -> (T_option ((T_pair ((T_int,()),(T_nat,())),(),())),()) :: s'
                         |I_ediv, (T_int,()) :: ((T_int | T_nat),()) :: s' -> (T_option ((T_pair ((T_int,()),(T_nat,())),(),())),()) :: s'
                         |I_ediv, (T_nat,()) :: (T_nat,()) :: s' -> (T_option ((T_pair ((T_nat,()),(T_nat,())),(),())),()) :: s'
                         |I_ediv, (T_mutez,()) :: (T_nat,()) :: s' -> (T_option ((T_pair ((T_mutez,()),(T_mutez,())),(),())),()) :: s'
                         |I_ediv, (T_mutez,()) :: (T_mutez,()) :: s' -> (T_option ((T_pair ((T_nat,()),(T_mutez,())),(),())),()) :: s'
                          |I_lsl, (T_nat,()) :: (T_nat,()) :: s' -> (T_nat,()) :: s'
                           |I_lsr, (T_nat,()) :: (T_nat,()) :: s' -> (T_nat,()) :: s'
                           |I_compare, (T_int,()) :: (T_int,()) :: s' -> (T_int,()) :: s'
                            |I_compare, (T_nat,()) :: (T_nat,()) :: s' -> (T_int,()) :: s'
                             |I_concat
                              |I_size
                               |I_slice
                                |I_pair
                                 |I_car
                                  |I_cdr
                                   |I_mem
                                    |I_update
                                     |I_get
                                      |I_some
                                       |I_cons
                                        |I_transfer_tokens
                                         |I_set_delegate
                                          |I_balance
                                           |I_address
                                            |I_source
                                             |I_sender
                                              |I_self
                                               |I_amount
                                                |I_implicit_account
                                                 |I_now
                                                  |I_chain_id
                                                   |I_pack
                                                    |I_hash_key
                                                     |I_blake2b
                                                      |I_sha256
                                                       |I_sha512
                                                        |I_check_signature
                                                         |I_unpair
                                                          |I_rename
                                                           |I_seq _
                                                            |I_if (_, _)
                                                             |I_loop _
                                                              |I_loop_left _
                                                               |I_dip _
                                                                |I_dip_n
                                                                 (_, _)
                                                                 |I_drop_n _
                                                                  |I_dig _
                                                                   |I_dug _
                                                                    |
                                                                    I_push
                                                                    (_, _)
                                                                    |
                                                                    I_lambda
                                                                    (_, _, _)
                                                                    |
                                                                    I_empty_set
                                                                    _
                                                                    |
                                                                    I_iter _
                                                                    |
                                                                    I_empty_map
                                                                    (_, _)
                                                                    |
                                                                    I_map _
                                                                    |
                                                                    I_empty_big_map
                                                                    (_, _)
                                                                    |
                                                                    I_none _
                                                                    |
                                                                    I_if_none
                                                                    (_, _)
                                                                    |
                                                                    I_left _
                                                                    |
                                                                    I_right _
                                                                    |
                                                                    I_if_left
                                                                    (_, _)
                                                                    |
                                                                    I_nil _
                                                                    |
                                                                    I_if_cons
                                                                    (_, _)
                                                                    |
                                                                    I_create_contract
                                                                    _
                                                                    |
                                                                    I_contract
                                                                    _
                                                                    |
                                                                    I_unpack
                                                                    _|I_cast
                                                                    _
    -> (??)
